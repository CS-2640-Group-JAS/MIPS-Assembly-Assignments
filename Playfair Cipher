# Anastasia Davis, Srivalli Kakumani, Jerold Manansala, and Jessica Pinto
# CS 2640.01
# 15 November, 2023
.macro addToString(%char)
	# Put the offset for editedPhrase into $t0.
	add $t0, $s1, $s3
	sb %char, ($t0)
	# Increment editedPhrase counter.
	addi $s3, $s3, 1
	# Move char to previous character for editedPhrase.
	move $t2, %char
.end_macro

.data
row1: .byte 'P', 'L', 'A', 'Y', 'F'
row2: .byte 'I', 'R', 'E', 'X', 'M'
row3: .byte 'B', 'C', 'D', 'G', 'H'
row4: .byte 'K', 'N', 'O', 'Q', 'S'
row5: .byte 'T', 'U', 'V', 'W', 'Z'

phrase: .asciiz "Doubling letters ... since every year rings silent."
testPhrase: .asciiz "`1234567890-=qwertyuiop[]\asdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:ZXCVBNM<>?"
editedPhrase: .space 500

.text
main:
	# Load the base address of phrase into $s0.
	la $s0, phrase
	# Load the base address of editedPhrase into $s1.
	la $s1, editedPhrase
	# Initialize the counter for phrase.
	move $s2, $zero
	# Initialize the counter for editedPhrase.
	move $s3, $zero
	# Initialize the previous character for editedPhrase (starts with no character).
	move $t2, $zero
checkString:
	# Put the offset for phrase into $t0.
	add $t0, $s0, $s2
	# Load the appropriate character of phrase into $t1.
	lb $t1, ($t0)
	# Increment phrase counter.
	addi $s2, $s2, 1
	# Check for end of string.
	beq $t1, 0, checkNumChars
	# Check for non-letters below uppercase asciis (skip).
	blt $t1, 65, checkString
	# Check for lowercase character (make uppercase).
	bgt $t1, 90, makeUpperCase
	j duplicateCheck
makeUpperCase:
	# Check for non-letters below/above lowercase asciis (skip).
	blt $t1, 97, checkString
	bgt $t1, 122, checkString
	# Make uppercase
	subi, $t1, $t1, 32
	j duplicateCheck
duplicateCheck:
	# Check for non-duplicate letters
	bne $t1, $t2, addChar
	# Check if editedPhrase counter is even (skip adding 'X') or odd (add 'X' to separate duplicates)
	# The result in $t3 will be 1 if odd and 0 if even.
	andi $t3, $s3, 0x0001
	beq $t3, 0, addChar
	li $t3, 'X'
	addToString($t3)
addChar:
	addToString($t1)
	j checkString
checkNumChars:
	# Check if editedPhrase counter is even (skip adding 'X') or odd (add 'X' to make even bigrams)
	# The result in $t3 will be 1 if odd and 0 if even.
	andi $t3, $s3, 0x0001
	beq $t3, 0, afterCheckString
	li $t3, 'X'
	addToString($t3)
afterCheckString:
	# Add the null terminator.
	addToString($t1)
	# Reinitialize the counter for editedPhrase.
	move $s3, $zero
	# Syscall for printing a character.
	li $v0, 11
printLoop:
	# Put the offset for editedPhrase into $t0.
	add $t0, $s1, $s3
	# Load the appropriate character of editedPhrase into $t1.
	lb $t1, ($t0)
	# Increment editedphrase counter.
	addi $s3, $s3, 1
	# Check for end of string.
	beq $t1, 0, encrypt
	# Else print the character.
	la $a0, ($t1)
	syscall
	# Check if editedPhrase counter is odd (don't add ' ') or even (add ' ')
	# The result in $t3 will be 1 if odd and 0 if even.
	andi $t3, $s3, 0x0001
	beq $t3, 1, printLoop
	# Print space.
	li $a0, ' '
	syscall
	j printLoop
encrypt: 
	# Encrypt each bigram separately.
	# 1. If the letters are on the same row, replace each with the letter immediately to the right (wraparound).
	# 2. If the letters are in the same column, replace each with the letter immediately below (wraparound).
	# 3. Else, replace with the letter in the same column as one letter and same row as the other.
	#	(Make a box out of the two letters, the missing corners are your new letters)
	#	Replace each letter with the corner letter in the **same row** as it.	
	# All previous used registers are now unnecessary. Reset $s0-$s3 and $t0 to 0.
	move $t0, $zero
	move $s0, $zero # Unnecessary since we set $s0 to an address in the next step.
	move $s1, $zero
	move $s2, $zero
	move $s3, $zero
	# Set $s0 to the base address for edittedPhrase.
	la $s0, editedPhrase
findRowColumn:

exit:
	li $v0, 10
	syscall
