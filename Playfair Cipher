# Anastasia Davis, Srivalli Kakumani, Jerold Manansala, and Jessica Pinto
# CS 2640.01
# 15 November, 2023
.macro addToString(%char)
	# Put the offset for editedPhrase into $t0.
	add $t0, $s1, $s3
	sb %char, ($t0)
	# Increment editedPhrase counter.
	addi $s3, $s3, 1
	# Move char to previous character for editedPhrase.
	move $t2, %char
.end_macro
.macro addBigram
	# Put the address of the table into $s1.
	la $s1, table
	# Put the corresponding row into $s2.
	mul $s5, $s5, 4
	add $s1, $s1, $s5
	lw $s2, ($s1)
	# Put the letter into $t1, and then encrypted phrase.
	add $s2, $s2, $s6
	lb $t1, ($s2)
	sb $t1, ($t4)
	# Increment encryptedPhrase to next byte.
	addi $t4, $t4, 1
	# Put the address of the table into $s1.
	la $s1, table
	# Put the corresponding row into $s2.
	mul $s3, $s3, 4
	add $s1, $s1, $s3
	lw $s2, ($s1)
	# Put the letter into $t1, and then encrypted phrase.
	add $s2, $s2, $s4
	lb $t1, ($s2)
	sb $t1, ($t4)
	# Increment encryptedPhrase to next byte.
	addi $t4, $t4, 1
.end_macro
.data
row1: .byte 'P', 'L', 'A', 'Y', 'F'
row2: .byte 'I', 'R', 'E', 'X', 'M'
row3: .byte 'B', 'C', 'D', 'G', 'H'
row4: .byte 'K', 'N', 'O', 'Q', 'S'
row5: .byte 'T', 'U', 'V', 'W', 'Z'
table: .word row1, row2, row3, row4, row5

phrase: .asciiz "Doubling letters ... since every year rings silent."
testPhrase: .asciiz "`1234567890-=qwertyuiop[]\asdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:ZXCVBNM<>?"
editedPhrase: .space 500
encryptedPhrase: .space 500
.text
main:
	# Load the base address of phrase into $s0.
	la $s0, phrase
	# Load the base address of editedPhrase into $s1.
	la $s1, editedPhrase
	# Initialize the counter for phrase.
	move $s2, $zero
	# Initialize the counter for editedPhrase.
	move $s3, $zero
	# Initialize the previous character for editedPhrase (starts with no character).
	move $t2, $zero
checkString:
	# Put the offset for phrase into $t0.
	add $t0, $s0, $s2
	# Load the appropriate character of phrase into $t1.
	lb $t1, ($t0)
	# Increment phrase counter.
	addi $s2, $s2, 1
	# Check for end of string.
	beq $t1, 0, checkNumChars
	# Check for non-letters below uppercase asciis (skip).
	blt $t1, 65, checkString
	# Check for lowercase character (make uppercase).
	bgt $t1, 90, makeUpperCase
	j jCheck
makeUpperCase:
	# Check for non-letters below/above lowercase asciis (skip).
	blt $t1, 97, checkString
	bgt $t1, 122, checkString
	# Make uppercase.
	subi, $t1, $t1, 32
jCheck:
	# Special case for 'J', convert to 'I'.
	bne $t1, 74, duplicateCheck
	li $t1, 73
duplicateCheck:
	# Check for non-duplicate letters.
	bne $t1, $t2, addChar
	# Check if editedPhrase counter is even (skip adding 'X') or odd (add 'X' to separate duplicates)
	# The result in $t3 will be 1 if odd and 0 if even.
	andi $t3, $s3, 0x0001
	beq $t3, 0, addChar
	li $t3, 'X'
	addToString($t3)
addChar:
	addToString($t1)
	j checkString
checkNumChars:
	# Check if editedPhrase counter is even (skip adding 'X') or odd (add 'X' to make even bigrams)
	# The result in $t3 will be 1 if odd and 0 if even.
	andi $t3, $s3, 0x0001
	beq $t3, 0, afterCheckString
	li $t3, 'X'
	addToString($t3)
afterCheckString:
	# Add the null terminator.
	addToString($t1)
	# Reinitialize the counter for editedPhrase.
	move $s3, $zero
	# Syscall for printing a character.
	li $v0, 11
printLoop:
	# Put the offset for editedPhrase into $t0.
	add $t0, $s1, $s3
	# Load the appropriate character of editedPhrase into $t1.
	lb $t1, ($t0)
	# Increment editedphrase counter.
	addi $s3, $s3, 1
	# Check for end of string.
	beq $t1, 0, endPrint
	# Else print the character.
	la $a0, ($t1)
	syscall
	# Check if editedPhrase counter is odd (don't add ' ') or even (add ' ')
	# The result in $t3 will be 1 if odd and 0 if even.
	andi $t3, $s3, 0x0001
	beq $t3, 1, printLoop
	# Print space.
	li $a0, ' '
	syscall
	j printLoop
endPrint:
	# Encrypt each bigram separately.
	# 1. (Jerold) If the letters are on the same row, replace each with the letter immediately to the right (wraparound).
	# 2. (Srivalli) If the letters are in the same column, replace each with the letter immediately below (wraparound).
	# 3. (Ana & Jess) Else, replace with the letter in the same column as one letter and same row as the other.
	#	(Make a box out of the two letters, the missing corners are your new letters)
	#	Replace each letter with the corner letter in the **same row** as it.
	# All previous used registers are now unnecessary. We can now resuse $s0-$s3 and $t0.
	# Set $s0 to the base address for edittedPhrase.
	la $s0, editedPhrase
	# $t2 will designate the first or second letter of the bigram.
	li $t2, 1
	# $t4 is the address of encryptedPhrase.
	la $t4, encryptedPhrase
encrypt:	
	la $s1, table	# Put the address of the table into $s1.
	# $s3 is the counter for the row, $s4 is the counter for the column.
	move $s3, $zero
	move $s4, $zero
	# Put the letter of editedPhrase into $t0.
	lb $t0, ($s0)
	# Check for null terminator character.
	beq $t0, 0, afterEncryption
findRow:
	# Put the corresponding row into $s2.
	lw $s2, ($s1)
	# Move to the next row by incrementing row
	addi $s1, $s1, 4
	addi $s3, $s3, 1
	# Reset column counter.
	move $s4, $zero
findColumn:
	# Put the letter from the table into $t1.
	lb $t1, ($s2)
	# Check if they are equal
	beq $t0, $t1, store
	# If they are not equal increment column and repeat.
	addi $s4, $s4, 1
	addi $s2, $s2 1
	# Check if we have reached the end of the column
	beq $s4, 5, findRow
	j findColumn
store:
	# Subtract 1 from row number to keep it consistent with column number.
	subi $s3, $s3, 1
	# Increment to the next letter of edited phrase.
	addi $s0, $s0, 1
	# Jump to afterFind once the second letter of the bigram has been found.
	beq $t2, 2 afterFind
	# Store the row and column where the letter was found.
	move $s5, $s3
	move $s6, $s4
	# Switch to the second letter of the bigram.
	li $t2, 2
	j encrypt
afterFind:
	# If the rows are equal, encode using first rule, if columns are equal, encode using second rule.
	beq $s3, $s5, case1
	beq $s4, $s6, case2
	# Else, encode using third rule.
	j case3
case1:	# Jerold
case2:	# Srivalli
case3:	# Jess & Ana
	# Swap the columns to get the column values for the new letters.
	move $s7, $s6
	move $s6, $s4
	move $s4, $s7
	# Add the two letters to encryptedPhrase
	addBigram
	# Reset to first letter of bigram and repeat.
	li $t2, 1
	j encrypt
afterEncryption:
	# Put the address of encryptedPhrase into $s1
	la $s1, encryptedPhrase
	# Reinitialize the counter for encryptedPhrase.
	move $s3, $zero
	# Syscall for printing a character.
	li $v0, 11
	# Add a newline character.
	li $a0, '\n'
	syscall
printLoop2:
	# Put the offset for encryptedPhrase into $t0.
	add $t0, $s1, $s3
	# Load the appropriate character of encryptedPhrase into $t1.
	lb $t1, ($t0)
	# Increment encryptedphrase counter.
	addi $s3, $s3, 1
	# Check for end of string.
	beq $t1, 0, exit
	# Else print the character.
	la $a0, ($t1)
	syscall
	# Check if encryptedPhrase counter is odd (don't add ' ') or even (add ' ')
	# The result in $t3 will be 1 if odd and 0 if even.
	andi $t3, $s3, 0x0001
	beq $t3, 1, printLoop2
	# Print space.
	li $a0, ' '
	syscall
	j printLoop2
exit:
	li $v0, 10
	syscall
